// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/contrib/tensorboard/plugins/trace/trace_info.proto

#ifndef PROTOBUF_tensorflow_2fcontrib_2ftensorboard_2fplugins_2ftrace_2ftrace_5finfo_2eproto__INCLUDED
#define PROTOBUF_tensorflow_2fcontrib_2ftensorboard_2fplugins_2ftrace_2ftrace_5finfo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3001000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3001000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/map.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace tensorflow {
namespace contrib {
namespace tensorboard {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_tensorflow_2fcontrib_2ftensorboard_2fplugins_2ftrace_2ftrace_5finfo_2eproto();
void protobuf_InitDefaults_tensorflow_2fcontrib_2ftensorboard_2fplugins_2ftrace_2ftrace_5finfo_2eproto();
void protobuf_AssignDesc_tensorflow_2fcontrib_2ftensorboard_2fplugins_2ftrace_2ftrace_5finfo_2eproto();
void protobuf_ShutdownFile_tensorflow_2fcontrib_2ftensorboard_2fplugins_2ftrace_2ftrace_5finfo_2eproto();

class FileInfo;
class LineTrace;
class OpInfo;
class TensorInfo;
class TraceInfo;

// ===================================================================

class TraceInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.contrib.tensorboard.TraceInfo) */ {
 public:
  TraceInfo();
  virtual ~TraceInfo();

  TraceInfo(const TraceInfo& from);

  inline TraceInfo& operator=(const TraceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TraceInfo& default_instance();

  static const TraceInfo* internal_default_instance();

  void Swap(TraceInfo* other);

  // implements Message ----------------------------------------------

  inline TraceInfo* New() const { return New(NULL); }

  TraceInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TraceInfo& from);
  void MergeFrom(const TraceInfo& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceInfo* other);
  void UnsafeMergeFrom(const TraceInfo& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tensorflow.contrib.tensorboard.OpInfo ops = 1;
  int ops_size() const;
  void clear_ops();
  static const int kOpsFieldNumber = 1;
  const ::tensorflow::contrib::tensorboard::OpInfo& ops(int index) const;
  ::tensorflow::contrib::tensorboard::OpInfo* mutable_ops(int index);
  ::tensorflow::contrib::tensorboard::OpInfo* add_ops();
  ::google::protobuf::RepeatedPtrField< ::tensorflow::contrib::tensorboard::OpInfo >*
      mutable_ops();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::contrib::tensorboard::OpInfo >&
      ops() const;

  // repeated .tensorflow.contrib.tensorboard.FileInfo files = 2;
  int files_size() const;
  void clear_files();
  static const int kFilesFieldNumber = 2;
  const ::tensorflow::contrib::tensorboard::FileInfo& files(int index) const;
  ::tensorflow::contrib::tensorboard::FileInfo* mutable_files(int index);
  ::tensorflow::contrib::tensorboard::FileInfo* add_files();
  ::google::protobuf::RepeatedPtrField< ::tensorflow::contrib::tensorboard::FileInfo >*
      mutable_files();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::contrib::tensorboard::FileInfo >&
      files() const;

  // @@protoc_insertion_point(class_scope:tensorflow.contrib.tensorboard.TraceInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::contrib::tensorboard::OpInfo > ops_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::contrib::tensorboard::FileInfo > files_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorflow_2fcontrib_2ftensorboard_2fplugins_2ftrace_2ftrace_5finfo_2eproto_impl();
  friend void  protobuf_AddDesc_tensorflow_2fcontrib_2ftensorboard_2fplugins_2ftrace_2ftrace_5finfo_2eproto_impl();
  friend void protobuf_AssignDesc_tensorflow_2fcontrib_2ftensorboard_2fplugins_2ftrace_2ftrace_5finfo_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcontrib_2ftensorboard_2fplugins_2ftrace_2ftrace_5finfo_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TraceInfo> TraceInfo_default_instance_;

// -------------------------------------------------------------------

class OpInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.contrib.tensorboard.OpInfo) */ {
 public:
  OpInfo();
  virtual ~OpInfo();

  OpInfo(const OpInfo& from);

  inline OpInfo& operator=(const OpInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OpInfo& default_instance();

  static const OpInfo* internal_default_instance();

  void Swap(OpInfo* other);

  // implements Message ----------------------------------------------

  inline OpInfo* New() const { return New(NULL); }

  OpInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OpInfo& from);
  void MergeFrom(const OpInfo& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OpInfo* other);
  void UnsafeMergeFrom(const OpInfo& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string op_type = 2;
  void clear_op_type();
  static const int kOpTypeFieldNumber = 2;
  const ::std::string& op_type() const;
  void set_op_type(const ::std::string& value);
  void set_op_type(const char* value);
  void set_op_type(const char* value, size_t size);
  ::std::string* mutable_op_type();
  ::std::string* release_op_type();
  void set_allocated_op_type(::std::string* op_type);

  // optional string device = 3;
  void clear_device();
  static const int kDeviceFieldNumber = 3;
  const ::std::string& device() const;
  void set_device(const ::std::string& value);
  void set_device(const char* value);
  void set_device(const char* value, size_t size);
  ::std::string* mutable_device();
  ::std::string* release_device();
  void set_allocated_device(::std::string* device);

  // repeated .tensorflow.contrib.tensorboard.LineTrace traceback = 4;
  int traceback_size() const;
  void clear_traceback();
  static const int kTracebackFieldNumber = 4;
  const ::tensorflow::contrib::tensorboard::LineTrace& traceback(int index) const;
  ::tensorflow::contrib::tensorboard::LineTrace* mutable_traceback(int index);
  ::tensorflow::contrib::tensorboard::LineTrace* add_traceback();
  ::google::protobuf::RepeatedPtrField< ::tensorflow::contrib::tensorboard::LineTrace >*
      mutable_traceback();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::contrib::tensorboard::LineTrace >&
      traceback() const;

  // repeated .tensorflow.contrib.tensorboard.TensorInfo inputs = 5;
  int inputs_size() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 5;
  const ::tensorflow::contrib::tensorboard::TensorInfo& inputs(int index) const;
  ::tensorflow::contrib::tensorboard::TensorInfo* mutable_inputs(int index);
  ::tensorflow::contrib::tensorboard::TensorInfo* add_inputs();
  ::google::protobuf::RepeatedPtrField< ::tensorflow::contrib::tensorboard::TensorInfo >*
      mutable_inputs();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::contrib::tensorboard::TensorInfo >&
      inputs() const;

  // repeated .tensorflow.contrib.tensorboard.TensorInfo outputs = 6;
  int outputs_size() const;
  void clear_outputs();
  static const int kOutputsFieldNumber = 6;
  const ::tensorflow::contrib::tensorboard::TensorInfo& outputs(int index) const;
  ::tensorflow::contrib::tensorboard::TensorInfo* mutable_outputs(int index);
  ::tensorflow::contrib::tensorboard::TensorInfo* add_outputs();
  ::google::protobuf::RepeatedPtrField< ::tensorflow::contrib::tensorboard::TensorInfo >*
      mutable_outputs();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::contrib::tensorboard::TensorInfo >&
      outputs() const;

  // @@protoc_insertion_point(class_scope:tensorflow.contrib.tensorboard.OpInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::contrib::tensorboard::LineTrace > traceback_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::contrib::tensorboard::TensorInfo > inputs_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::contrib::tensorboard::TensorInfo > outputs_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr op_type_;
  ::google::protobuf::internal::ArenaStringPtr device_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorflow_2fcontrib_2ftensorboard_2fplugins_2ftrace_2ftrace_5finfo_2eproto_impl();
  friend void  protobuf_AddDesc_tensorflow_2fcontrib_2ftensorboard_2fplugins_2ftrace_2ftrace_5finfo_2eproto_impl();
  friend void protobuf_AssignDesc_tensorflow_2fcontrib_2ftensorboard_2fplugins_2ftrace_2ftrace_5finfo_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcontrib_2ftensorboard_2fplugins_2ftrace_2ftrace_5finfo_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<OpInfo> OpInfo_default_instance_;

// -------------------------------------------------------------------

class LineTrace : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.contrib.tensorboard.LineTrace) */ {
 public:
  LineTrace();
  virtual ~LineTrace();

  LineTrace(const LineTrace& from);

  inline LineTrace& operator=(const LineTrace& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LineTrace& default_instance();

  static const LineTrace* internal_default_instance();

  void Swap(LineTrace* other);

  // implements Message ----------------------------------------------

  inline LineTrace* New() const { return New(NULL); }

  LineTrace* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LineTrace& from);
  void MergeFrom(const LineTrace& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LineTrace* other);
  void UnsafeMergeFrom(const LineTrace& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string file_path = 1;
  void clear_file_path();
  static const int kFilePathFieldNumber = 1;
  const ::std::string& file_path() const;
  void set_file_path(const ::std::string& value);
  void set_file_path(const char* value);
  void set_file_path(const char* value, size_t size);
  ::std::string* mutable_file_path();
  ::std::string* release_file_path();
  void set_allocated_file_path(::std::string* file_path);

  // optional uint32 line_number = 2;
  void clear_line_number();
  static const int kLineNumberFieldNumber = 2;
  ::google::protobuf::uint32 line_number() const;
  void set_line_number(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:tensorflow.contrib.tensorboard.LineTrace)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr file_path_;
  ::google::protobuf::uint32 line_number_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorflow_2fcontrib_2ftensorboard_2fplugins_2ftrace_2ftrace_5finfo_2eproto_impl();
  friend void  protobuf_AddDesc_tensorflow_2fcontrib_2ftensorboard_2fplugins_2ftrace_2ftrace_5finfo_2eproto_impl();
  friend void protobuf_AssignDesc_tensorflow_2fcontrib_2ftensorboard_2fplugins_2ftrace_2ftrace_5finfo_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcontrib_2ftensorboard_2fplugins_2ftrace_2ftrace_5finfo_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<LineTrace> LineTrace_default_instance_;

// -------------------------------------------------------------------

class TensorInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.contrib.tensorboard.TensorInfo) */ {
 public:
  TensorInfo();
  virtual ~TensorInfo();

  TensorInfo(const TensorInfo& from);

  inline TensorInfo& operator=(const TensorInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TensorInfo& default_instance();

  static const TensorInfo* internal_default_instance();

  void Swap(TensorInfo* other);

  // implements Message ----------------------------------------------

  inline TensorInfo* New() const { return New(NULL); }

  TensorInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TensorInfo& from);
  void MergeFrom(const TensorInfo& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TensorInfo* other);
  void UnsafeMergeFrom(const TensorInfo& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 shape = 1;
  int shape_size() const;
  void clear_shape();
  static const int kShapeFieldNumber = 1;
  ::google::protobuf::int32 shape(int index) const;
  void set_shape(int index, ::google::protobuf::int32 value);
  void add_shape(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      shape() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_shape();

  // optional string dtype = 2;
  void clear_dtype();
  static const int kDtypeFieldNumber = 2;
  const ::std::string& dtype() const;
  void set_dtype(const ::std::string& value);
  void set_dtype(const char* value);
  void set_dtype(const char* value, size_t size);
  ::std::string* mutable_dtype();
  ::std::string* release_dtype();
  void set_allocated_dtype(::std::string* dtype);

  // optional uint32 num_bytes_per_elem = 3;
  void clear_num_bytes_per_elem();
  static const int kNumBytesPerElemFieldNumber = 3;
  ::google::protobuf::uint32 num_bytes_per_elem() const;
  void set_num_bytes_per_elem(::google::protobuf::uint32 value);

  // repeated string consumers = 4;
  int consumers_size() const;
  void clear_consumers();
  static const int kConsumersFieldNumber = 4;
  const ::std::string& consumers(int index) const;
  ::std::string* mutable_consumers(int index);
  void set_consumers(int index, const ::std::string& value);
  void set_consumers(int index, const char* value);
  void set_consumers(int index, const char* value, size_t size);
  ::std::string* add_consumers();
  void add_consumers(const ::std::string& value);
  void add_consumers(const char* value);
  void add_consumers(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& consumers() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_consumers();

  // @@protoc_insertion_point(class_scope:tensorflow.contrib.tensorboard.TensorInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > shape_;
  mutable int _shape_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> consumers_;
  ::google::protobuf::internal::ArenaStringPtr dtype_;
  ::google::protobuf::uint32 num_bytes_per_elem_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorflow_2fcontrib_2ftensorboard_2fplugins_2ftrace_2ftrace_5finfo_2eproto_impl();
  friend void  protobuf_AddDesc_tensorflow_2fcontrib_2ftensorboard_2fplugins_2ftrace_2ftrace_5finfo_2eproto_impl();
  friend void protobuf_AssignDesc_tensorflow_2fcontrib_2ftensorboard_2fplugins_2ftrace_2ftrace_5finfo_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcontrib_2ftensorboard_2fplugins_2ftrace_2ftrace_5finfo_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TensorInfo> TensorInfo_default_instance_;

// -------------------------------------------------------------------

class FileInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.contrib.tensorboard.FileInfo) */ {
 public:
  FileInfo();
  virtual ~FileInfo();

  FileInfo(const FileInfo& from);

  inline FileInfo& operator=(const FileInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FileInfo& default_instance();

  static const FileInfo* internal_default_instance();

  void Swap(FileInfo* other);

  // implements Message ----------------------------------------------

  inline FileInfo* New() const { return New(NULL); }

  FileInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileInfo& from);
  void MergeFrom(const FileInfo& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FileInfo* other);
  void UnsafeMergeFrom(const FileInfo& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // optional string file_path = 1;
  void clear_file_path();
  static const int kFilePathFieldNumber = 1;
  const ::std::string& file_path() const;
  void set_file_path(const ::std::string& value);
  void set_file_path(const char* value);
  void set_file_path(const char* value, size_t size);
  ::std::string* mutable_file_path();
  ::std::string* release_file_path();
  void set_allocated_file_path(::std::string* file_path);

  // optional string source_code = 2;
  void clear_source_code();
  static const int kSourceCodeFieldNumber = 2;
  const ::std::string& source_code() const;
  void set_source_code(const ::std::string& value);
  void set_source_code(const char* value);
  void set_source_code(const char* value, size_t size);
  ::std::string* mutable_source_code();
  ::std::string* release_source_code();
  void set_allocated_source_code(::std::string* source_code);

  // map<uint32, uint32> multiline_statements = 3;
  int multiline_statements_size() const;
  void clear_multiline_statements();
  static const int kMultilineStatementsFieldNumber = 3;
  const ::google::protobuf::Map< ::google::protobuf::uint32, ::google::protobuf::uint32 >&
      multiline_statements() const;
  ::google::protobuf::Map< ::google::protobuf::uint32, ::google::protobuf::uint32 >*
      mutable_multiline_statements();

  // @@protoc_insertion_point(class_scope:tensorflow.contrib.tensorboard.FileInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  typedef ::google::protobuf::internal::MapEntryLite<
      ::google::protobuf::uint32, ::google::protobuf::uint32,
      ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
      0 >
      FileInfo_MultilineStatementsEntry;
  ::google::protobuf::internal::MapField<
      ::google::protobuf::uint32, ::google::protobuf::uint32,
      ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
      0 > multiline_statements_;
  ::google::protobuf::internal::ArenaStringPtr file_path_;
  ::google::protobuf::internal::ArenaStringPtr source_code_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorflow_2fcontrib_2ftensorboard_2fplugins_2ftrace_2ftrace_5finfo_2eproto_impl();
  friend void  protobuf_AddDesc_tensorflow_2fcontrib_2ftensorboard_2fplugins_2ftrace_2ftrace_5finfo_2eproto_impl();
  friend void protobuf_AssignDesc_tensorflow_2fcontrib_2ftensorboard_2fplugins_2ftrace_2ftrace_5finfo_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcontrib_2ftensorboard_2fplugins_2ftrace_2ftrace_5finfo_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<FileInfo> FileInfo_default_instance_;

// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// TraceInfo

// repeated .tensorflow.contrib.tensorboard.OpInfo ops = 1;
inline int TraceInfo::ops_size() const {
  return ops_.size();
}
inline void TraceInfo::clear_ops() {
  ops_.Clear();
}
inline const ::tensorflow::contrib::tensorboard::OpInfo& TraceInfo::ops(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.contrib.tensorboard.TraceInfo.ops)
  return ops_.Get(index);
}
inline ::tensorflow::contrib::tensorboard::OpInfo* TraceInfo::mutable_ops(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.contrib.tensorboard.TraceInfo.ops)
  return ops_.Mutable(index);
}
inline ::tensorflow::contrib::tensorboard::OpInfo* TraceInfo::add_ops() {
  // @@protoc_insertion_point(field_add:tensorflow.contrib.tensorboard.TraceInfo.ops)
  return ops_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::contrib::tensorboard::OpInfo >*
TraceInfo::mutable_ops() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.contrib.tensorboard.TraceInfo.ops)
  return &ops_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::contrib::tensorboard::OpInfo >&
TraceInfo::ops() const {
  // @@protoc_insertion_point(field_list:tensorflow.contrib.tensorboard.TraceInfo.ops)
  return ops_;
}

// repeated .tensorflow.contrib.tensorboard.FileInfo files = 2;
inline int TraceInfo::files_size() const {
  return files_.size();
}
inline void TraceInfo::clear_files() {
  files_.Clear();
}
inline const ::tensorflow::contrib::tensorboard::FileInfo& TraceInfo::files(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.contrib.tensorboard.TraceInfo.files)
  return files_.Get(index);
}
inline ::tensorflow::contrib::tensorboard::FileInfo* TraceInfo::mutable_files(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.contrib.tensorboard.TraceInfo.files)
  return files_.Mutable(index);
}
inline ::tensorflow::contrib::tensorboard::FileInfo* TraceInfo::add_files() {
  // @@protoc_insertion_point(field_add:tensorflow.contrib.tensorboard.TraceInfo.files)
  return files_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::contrib::tensorboard::FileInfo >*
TraceInfo::mutable_files() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.contrib.tensorboard.TraceInfo.files)
  return &files_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::contrib::tensorboard::FileInfo >&
TraceInfo::files() const {
  // @@protoc_insertion_point(field_list:tensorflow.contrib.tensorboard.TraceInfo.files)
  return files_;
}

inline const TraceInfo* TraceInfo::internal_default_instance() {
  return &TraceInfo_default_instance_.get();
}
// -------------------------------------------------------------------

// OpInfo

// optional string name = 1;
inline void OpInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OpInfo::name() const {
  // @@protoc_insertion_point(field_get:tensorflow.contrib.tensorboard.OpInfo.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpInfo::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.contrib.tensorboard.OpInfo.name)
}
inline void OpInfo::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.contrib.tensorboard.OpInfo.name)
}
inline void OpInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.contrib.tensorboard.OpInfo.name)
}
inline ::std::string* OpInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.contrib.tensorboard.OpInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpInfo::release_name() {
  // @@protoc_insertion_point(field_release:tensorflow.contrib.tensorboard.OpInfo.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.contrib.tensorboard.OpInfo.name)
}

// optional string op_type = 2;
inline void OpInfo::clear_op_type() {
  op_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OpInfo::op_type() const {
  // @@protoc_insertion_point(field_get:tensorflow.contrib.tensorboard.OpInfo.op_type)
  return op_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpInfo::set_op_type(const ::std::string& value) {
  
  op_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.contrib.tensorboard.OpInfo.op_type)
}
inline void OpInfo::set_op_type(const char* value) {
  
  op_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.contrib.tensorboard.OpInfo.op_type)
}
inline void OpInfo::set_op_type(const char* value, size_t size) {
  
  op_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.contrib.tensorboard.OpInfo.op_type)
}
inline ::std::string* OpInfo::mutable_op_type() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.contrib.tensorboard.OpInfo.op_type)
  return op_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpInfo::release_op_type() {
  // @@protoc_insertion_point(field_release:tensorflow.contrib.tensorboard.OpInfo.op_type)
  
  return op_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpInfo::set_allocated_op_type(::std::string* op_type) {
  if (op_type != NULL) {
    
  } else {
    
  }
  op_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), op_type);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.contrib.tensorboard.OpInfo.op_type)
}

// optional string device = 3;
inline void OpInfo::clear_device() {
  device_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OpInfo::device() const {
  // @@protoc_insertion_point(field_get:tensorflow.contrib.tensorboard.OpInfo.device)
  return device_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpInfo::set_device(const ::std::string& value) {
  
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.contrib.tensorboard.OpInfo.device)
}
inline void OpInfo::set_device(const char* value) {
  
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.contrib.tensorboard.OpInfo.device)
}
inline void OpInfo::set_device(const char* value, size_t size) {
  
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.contrib.tensorboard.OpInfo.device)
}
inline ::std::string* OpInfo::mutable_device() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.contrib.tensorboard.OpInfo.device)
  return device_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpInfo::release_device() {
  // @@protoc_insertion_point(field_release:tensorflow.contrib.tensorboard.OpInfo.device)
  
  return device_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpInfo::set_allocated_device(::std::string* device) {
  if (device != NULL) {
    
  } else {
    
  }
  device_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.contrib.tensorboard.OpInfo.device)
}

// repeated .tensorflow.contrib.tensorboard.LineTrace traceback = 4;
inline int OpInfo::traceback_size() const {
  return traceback_.size();
}
inline void OpInfo::clear_traceback() {
  traceback_.Clear();
}
inline const ::tensorflow::contrib::tensorboard::LineTrace& OpInfo::traceback(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.contrib.tensorboard.OpInfo.traceback)
  return traceback_.Get(index);
}
inline ::tensorflow::contrib::tensorboard::LineTrace* OpInfo::mutable_traceback(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.contrib.tensorboard.OpInfo.traceback)
  return traceback_.Mutable(index);
}
inline ::tensorflow::contrib::tensorboard::LineTrace* OpInfo::add_traceback() {
  // @@protoc_insertion_point(field_add:tensorflow.contrib.tensorboard.OpInfo.traceback)
  return traceback_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::contrib::tensorboard::LineTrace >*
OpInfo::mutable_traceback() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.contrib.tensorboard.OpInfo.traceback)
  return &traceback_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::contrib::tensorboard::LineTrace >&
OpInfo::traceback() const {
  // @@protoc_insertion_point(field_list:tensorflow.contrib.tensorboard.OpInfo.traceback)
  return traceback_;
}

// repeated .tensorflow.contrib.tensorboard.TensorInfo inputs = 5;
inline int OpInfo::inputs_size() const {
  return inputs_.size();
}
inline void OpInfo::clear_inputs() {
  inputs_.Clear();
}
inline const ::tensorflow::contrib::tensorboard::TensorInfo& OpInfo::inputs(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.contrib.tensorboard.OpInfo.inputs)
  return inputs_.Get(index);
}
inline ::tensorflow::contrib::tensorboard::TensorInfo* OpInfo::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.contrib.tensorboard.OpInfo.inputs)
  return inputs_.Mutable(index);
}
inline ::tensorflow::contrib::tensorboard::TensorInfo* OpInfo::add_inputs() {
  // @@protoc_insertion_point(field_add:tensorflow.contrib.tensorboard.OpInfo.inputs)
  return inputs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::contrib::tensorboard::TensorInfo >*
OpInfo::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.contrib.tensorboard.OpInfo.inputs)
  return &inputs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::contrib::tensorboard::TensorInfo >&
OpInfo::inputs() const {
  // @@protoc_insertion_point(field_list:tensorflow.contrib.tensorboard.OpInfo.inputs)
  return inputs_;
}

// repeated .tensorflow.contrib.tensorboard.TensorInfo outputs = 6;
inline int OpInfo::outputs_size() const {
  return outputs_.size();
}
inline void OpInfo::clear_outputs() {
  outputs_.Clear();
}
inline const ::tensorflow::contrib::tensorboard::TensorInfo& OpInfo::outputs(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.contrib.tensorboard.OpInfo.outputs)
  return outputs_.Get(index);
}
inline ::tensorflow::contrib::tensorboard::TensorInfo* OpInfo::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.contrib.tensorboard.OpInfo.outputs)
  return outputs_.Mutable(index);
}
inline ::tensorflow::contrib::tensorboard::TensorInfo* OpInfo::add_outputs() {
  // @@protoc_insertion_point(field_add:tensorflow.contrib.tensorboard.OpInfo.outputs)
  return outputs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::contrib::tensorboard::TensorInfo >*
OpInfo::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.contrib.tensorboard.OpInfo.outputs)
  return &outputs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::contrib::tensorboard::TensorInfo >&
OpInfo::outputs() const {
  // @@protoc_insertion_point(field_list:tensorflow.contrib.tensorboard.OpInfo.outputs)
  return outputs_;
}

inline const OpInfo* OpInfo::internal_default_instance() {
  return &OpInfo_default_instance_.get();
}
// -------------------------------------------------------------------

// LineTrace

// optional string file_path = 1;
inline void LineTrace::clear_file_path() {
  file_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LineTrace::file_path() const {
  // @@protoc_insertion_point(field_get:tensorflow.contrib.tensorboard.LineTrace.file_path)
  return file_path_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LineTrace::set_file_path(const ::std::string& value) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.contrib.tensorboard.LineTrace.file_path)
}
inline void LineTrace::set_file_path(const char* value) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.contrib.tensorboard.LineTrace.file_path)
}
inline void LineTrace::set_file_path(const char* value, size_t size) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.contrib.tensorboard.LineTrace.file_path)
}
inline ::std::string* LineTrace::mutable_file_path() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.contrib.tensorboard.LineTrace.file_path)
  return file_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LineTrace::release_file_path() {
  // @@protoc_insertion_point(field_release:tensorflow.contrib.tensorboard.LineTrace.file_path)
  
  return file_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LineTrace::set_allocated_file_path(::std::string* file_path) {
  if (file_path != NULL) {
    
  } else {
    
  }
  file_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_path);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.contrib.tensorboard.LineTrace.file_path)
}

// optional uint32 line_number = 2;
inline void LineTrace::clear_line_number() {
  line_number_ = 0u;
}
inline ::google::protobuf::uint32 LineTrace::line_number() const {
  // @@protoc_insertion_point(field_get:tensorflow.contrib.tensorboard.LineTrace.line_number)
  return line_number_;
}
inline void LineTrace::set_line_number(::google::protobuf::uint32 value) {
  
  line_number_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.contrib.tensorboard.LineTrace.line_number)
}

inline const LineTrace* LineTrace::internal_default_instance() {
  return &LineTrace_default_instance_.get();
}
// -------------------------------------------------------------------

// TensorInfo

// repeated int32 shape = 1;
inline int TensorInfo::shape_size() const {
  return shape_.size();
}
inline void TensorInfo::clear_shape() {
  shape_.Clear();
}
inline ::google::protobuf::int32 TensorInfo::shape(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.contrib.tensorboard.TensorInfo.shape)
  return shape_.Get(index);
}
inline void TensorInfo::set_shape(int index, ::google::protobuf::int32 value) {
  shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.contrib.tensorboard.TensorInfo.shape)
}
inline void TensorInfo::add_shape(::google::protobuf::int32 value) {
  shape_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.contrib.tensorboard.TensorInfo.shape)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
TensorInfo::shape() const {
  // @@protoc_insertion_point(field_list:tensorflow.contrib.tensorboard.TensorInfo.shape)
  return shape_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
TensorInfo::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.contrib.tensorboard.TensorInfo.shape)
  return &shape_;
}

// optional string dtype = 2;
inline void TensorInfo::clear_dtype() {
  dtype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TensorInfo::dtype() const {
  // @@protoc_insertion_point(field_get:tensorflow.contrib.tensorboard.TensorInfo.dtype)
  return dtype_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TensorInfo::set_dtype(const ::std::string& value) {
  
  dtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.contrib.tensorboard.TensorInfo.dtype)
}
inline void TensorInfo::set_dtype(const char* value) {
  
  dtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.contrib.tensorboard.TensorInfo.dtype)
}
inline void TensorInfo::set_dtype(const char* value, size_t size) {
  
  dtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.contrib.tensorboard.TensorInfo.dtype)
}
inline ::std::string* TensorInfo::mutable_dtype() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.contrib.tensorboard.TensorInfo.dtype)
  return dtype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TensorInfo::release_dtype() {
  // @@protoc_insertion_point(field_release:tensorflow.contrib.tensorboard.TensorInfo.dtype)
  
  return dtype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TensorInfo::set_allocated_dtype(::std::string* dtype) {
  if (dtype != NULL) {
    
  } else {
    
  }
  dtype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dtype);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.contrib.tensorboard.TensorInfo.dtype)
}

// optional uint32 num_bytes_per_elem = 3;
inline void TensorInfo::clear_num_bytes_per_elem() {
  num_bytes_per_elem_ = 0u;
}
inline ::google::protobuf::uint32 TensorInfo::num_bytes_per_elem() const {
  // @@protoc_insertion_point(field_get:tensorflow.contrib.tensorboard.TensorInfo.num_bytes_per_elem)
  return num_bytes_per_elem_;
}
inline void TensorInfo::set_num_bytes_per_elem(::google::protobuf::uint32 value) {
  
  num_bytes_per_elem_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.contrib.tensorboard.TensorInfo.num_bytes_per_elem)
}

// repeated string consumers = 4;
inline int TensorInfo::consumers_size() const {
  return consumers_.size();
}
inline void TensorInfo::clear_consumers() {
  consumers_.Clear();
}
inline const ::std::string& TensorInfo::consumers(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.contrib.tensorboard.TensorInfo.consumers)
  return consumers_.Get(index);
}
inline ::std::string* TensorInfo::mutable_consumers(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.contrib.tensorboard.TensorInfo.consumers)
  return consumers_.Mutable(index);
}
inline void TensorInfo::set_consumers(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorflow.contrib.tensorboard.TensorInfo.consumers)
  consumers_.Mutable(index)->assign(value);
}
inline void TensorInfo::set_consumers(int index, const char* value) {
  consumers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tensorflow.contrib.tensorboard.TensorInfo.consumers)
}
inline void TensorInfo::set_consumers(int index, const char* value, size_t size) {
  consumers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tensorflow.contrib.tensorboard.TensorInfo.consumers)
}
inline ::std::string* TensorInfo::add_consumers() {
  // @@protoc_insertion_point(field_add_mutable:tensorflow.contrib.tensorboard.TensorInfo.consumers)
  return consumers_.Add();
}
inline void TensorInfo::add_consumers(const ::std::string& value) {
  consumers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tensorflow.contrib.tensorboard.TensorInfo.consumers)
}
inline void TensorInfo::add_consumers(const char* value) {
  consumers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tensorflow.contrib.tensorboard.TensorInfo.consumers)
}
inline void TensorInfo::add_consumers(const char* value, size_t size) {
  consumers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tensorflow.contrib.tensorboard.TensorInfo.consumers)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TensorInfo::consumers() const {
  // @@protoc_insertion_point(field_list:tensorflow.contrib.tensorboard.TensorInfo.consumers)
  return consumers_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TensorInfo::mutable_consumers() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.contrib.tensorboard.TensorInfo.consumers)
  return &consumers_;
}

inline const TensorInfo* TensorInfo::internal_default_instance() {
  return &TensorInfo_default_instance_.get();
}
// -------------------------------------------------------------------

// FileInfo

// optional string file_path = 1;
inline void FileInfo::clear_file_path() {
  file_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileInfo::file_path() const {
  // @@protoc_insertion_point(field_get:tensorflow.contrib.tensorboard.FileInfo.file_path)
  return file_path_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileInfo::set_file_path(const ::std::string& value) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.contrib.tensorboard.FileInfo.file_path)
}
inline void FileInfo::set_file_path(const char* value) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.contrib.tensorboard.FileInfo.file_path)
}
inline void FileInfo::set_file_path(const char* value, size_t size) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.contrib.tensorboard.FileInfo.file_path)
}
inline ::std::string* FileInfo::mutable_file_path() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.contrib.tensorboard.FileInfo.file_path)
  return file_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileInfo::release_file_path() {
  // @@protoc_insertion_point(field_release:tensorflow.contrib.tensorboard.FileInfo.file_path)
  
  return file_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileInfo::set_allocated_file_path(::std::string* file_path) {
  if (file_path != NULL) {
    
  } else {
    
  }
  file_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_path);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.contrib.tensorboard.FileInfo.file_path)
}

// optional string source_code = 2;
inline void FileInfo::clear_source_code() {
  source_code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileInfo::source_code() const {
  // @@protoc_insertion_point(field_get:tensorflow.contrib.tensorboard.FileInfo.source_code)
  return source_code_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileInfo::set_source_code(const ::std::string& value) {
  
  source_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.contrib.tensorboard.FileInfo.source_code)
}
inline void FileInfo::set_source_code(const char* value) {
  
  source_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.contrib.tensorboard.FileInfo.source_code)
}
inline void FileInfo::set_source_code(const char* value, size_t size) {
  
  source_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.contrib.tensorboard.FileInfo.source_code)
}
inline ::std::string* FileInfo::mutable_source_code() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.contrib.tensorboard.FileInfo.source_code)
  return source_code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileInfo::release_source_code() {
  // @@protoc_insertion_point(field_release:tensorflow.contrib.tensorboard.FileInfo.source_code)
  
  return source_code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileInfo::set_allocated_source_code(::std::string* source_code) {
  if (source_code != NULL) {
    
  } else {
    
  }
  source_code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source_code);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.contrib.tensorboard.FileInfo.source_code)
}

// map<uint32, uint32> multiline_statements = 3;
inline int FileInfo::multiline_statements_size() const {
  return multiline_statements_.size();
}
inline void FileInfo::clear_multiline_statements() {
  multiline_statements_.Clear();
}
inline const ::google::protobuf::Map< ::google::protobuf::uint32, ::google::protobuf::uint32 >&
FileInfo::multiline_statements() const {
  // @@protoc_insertion_point(field_map:tensorflow.contrib.tensorboard.FileInfo.multiline_statements)
  return multiline_statements_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::uint32, ::google::protobuf::uint32 >*
FileInfo::mutable_multiline_statements() {
  // @@protoc_insertion_point(field_mutable_map:tensorflow.contrib.tensorboard.FileInfo.multiline_statements)
  return multiline_statements_.MutableMap();
}

inline const FileInfo* FileInfo::internal_default_instance() {
  return &FileInfo_default_instance_.get();
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tensorboard
}  // namespace contrib
}  // namespace tensorflow

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_tensorflow_2fcontrib_2ftensorboard_2fplugins_2ftrace_2ftrace_5finfo_2eproto__INCLUDED
