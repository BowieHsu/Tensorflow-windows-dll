// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/contrib/training/python/training/hparam.proto

#ifndef PROTOBUF_tensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto__INCLUDED
#define PROTOBUF_tensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3001000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3001000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/map.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace tensorflow {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_tensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto();
void protobuf_InitDefaults_tensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto();
void protobuf_AssignDesc_tensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto();
void protobuf_ShutdownFile_tensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto();

class HParamDef;
class HParamDef_BoolList;
class HParamDef_BytesList;
class HParamDef_FloatList;
class HParamDef_HParamType;
class HParamDef_Int64List;

// ===================================================================

class HParamDef_BytesList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.HParamDef.BytesList) */ {
 public:
  HParamDef_BytesList();
  virtual ~HParamDef_BytesList();

  HParamDef_BytesList(const HParamDef_BytesList& from);

  inline HParamDef_BytesList& operator=(const HParamDef_BytesList& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const HParamDef_BytesList& default_instance();

  static const HParamDef_BytesList* internal_default_instance();

  void UnsafeArenaSwap(HParamDef_BytesList* other);
  void Swap(HParamDef_BytesList* other);

  // implements Message ----------------------------------------------

  inline HParamDef_BytesList* New() const { return New(NULL); }

  HParamDef_BytesList* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HParamDef_BytesList& from);
  void MergeFrom(const HParamDef_BytesList& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HParamDef_BytesList* other);
  void UnsafeMergeFrom(const HParamDef_BytesList& from);
  protected:
  explicit HParamDef_BytesList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes value = 1;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value(int index) const;
  ::std::string* mutable_value(int index);
  void set_value(int index, const ::std::string& value);
  void set_value(int index, const char* value);
  void set_value(int index, const void* value, size_t size);
  ::std::string* add_value();
  void add_value(const ::std::string& value);
  void add_value(const char* value);
  void add_value(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& value() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_value();

  // @@protoc_insertion_point(class_scope:tensorflow.HParamDef.BytesList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::std::string> value_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto_impl();
  friend void  protobuf_AddDesc_tensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto_impl();
  friend void protobuf_AssignDesc_tensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<HParamDef_BytesList> HParamDef_BytesList_default_instance_;

// -------------------------------------------------------------------

class HParamDef_FloatList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.HParamDef.FloatList) */ {
 public:
  HParamDef_FloatList();
  virtual ~HParamDef_FloatList();

  HParamDef_FloatList(const HParamDef_FloatList& from);

  inline HParamDef_FloatList& operator=(const HParamDef_FloatList& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const HParamDef_FloatList& default_instance();

  static const HParamDef_FloatList* internal_default_instance();

  void UnsafeArenaSwap(HParamDef_FloatList* other);
  void Swap(HParamDef_FloatList* other);

  // implements Message ----------------------------------------------

  inline HParamDef_FloatList* New() const { return New(NULL); }

  HParamDef_FloatList* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HParamDef_FloatList& from);
  void MergeFrom(const HParamDef_FloatList& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HParamDef_FloatList* other);
  void UnsafeMergeFrom(const HParamDef_FloatList& from);
  protected:
  explicit HParamDef_FloatList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float value = 1 [packed = true];
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  float value(int index) const;
  void set_value(int index, float value);
  void add_value(float value);
  const ::google::protobuf::RepeatedField< float >&
      value() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:tensorflow.HParamDef.FloatList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedField< float > value_;
  mutable int _value_cached_byte_size_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto_impl();
  friend void  protobuf_AddDesc_tensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto_impl();
  friend void protobuf_AssignDesc_tensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<HParamDef_FloatList> HParamDef_FloatList_default_instance_;

// -------------------------------------------------------------------

class HParamDef_Int64List : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.HParamDef.Int64List) */ {
 public:
  HParamDef_Int64List();
  virtual ~HParamDef_Int64List();

  HParamDef_Int64List(const HParamDef_Int64List& from);

  inline HParamDef_Int64List& operator=(const HParamDef_Int64List& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const HParamDef_Int64List& default_instance();

  static const HParamDef_Int64List* internal_default_instance();

  void UnsafeArenaSwap(HParamDef_Int64List* other);
  void Swap(HParamDef_Int64List* other);

  // implements Message ----------------------------------------------

  inline HParamDef_Int64List* New() const { return New(NULL); }

  HParamDef_Int64List* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HParamDef_Int64List& from);
  void MergeFrom(const HParamDef_Int64List& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HParamDef_Int64List* other);
  void UnsafeMergeFrom(const HParamDef_Int64List& from);
  protected:
  explicit HParamDef_Int64List(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 value = 1 [packed = true];
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::int64 value(int index) const;
  void set_value(int index, ::google::protobuf::int64 value);
  void add_value(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      value() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:tensorflow.HParamDef.Int64List)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > value_;
  mutable int _value_cached_byte_size_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto_impl();
  friend void  protobuf_AddDesc_tensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto_impl();
  friend void protobuf_AssignDesc_tensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<HParamDef_Int64List> HParamDef_Int64List_default_instance_;

// -------------------------------------------------------------------

class HParamDef_BoolList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.HParamDef.BoolList) */ {
 public:
  HParamDef_BoolList();
  virtual ~HParamDef_BoolList();

  HParamDef_BoolList(const HParamDef_BoolList& from);

  inline HParamDef_BoolList& operator=(const HParamDef_BoolList& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const HParamDef_BoolList& default_instance();

  static const HParamDef_BoolList* internal_default_instance();

  void UnsafeArenaSwap(HParamDef_BoolList* other);
  void Swap(HParamDef_BoolList* other);

  // implements Message ----------------------------------------------

  inline HParamDef_BoolList* New() const { return New(NULL); }

  HParamDef_BoolList* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HParamDef_BoolList& from);
  void MergeFrom(const HParamDef_BoolList& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HParamDef_BoolList* other);
  void UnsafeMergeFrom(const HParamDef_BoolList& from);
  protected:
  explicit HParamDef_BoolList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bool value = 1 [packed = true];
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  bool value(int index) const;
  void set_value(int index, bool value);
  void add_value(bool value);
  const ::google::protobuf::RepeatedField< bool >&
      value() const;
  ::google::protobuf::RepeatedField< bool >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:tensorflow.HParamDef.BoolList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedField< bool > value_;
  mutable int _value_cached_byte_size_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto_impl();
  friend void  protobuf_AddDesc_tensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto_impl();
  friend void protobuf_AssignDesc_tensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<HParamDef_BoolList> HParamDef_BoolList_default_instance_;

// -------------------------------------------------------------------

class HParamDef_HParamType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.HParamDef.HParamType) */ {
 public:
  HParamDef_HParamType();
  virtual ~HParamDef_HParamType();

  HParamDef_HParamType(const HParamDef_HParamType& from);

  inline HParamDef_HParamType& operator=(const HParamDef_HParamType& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const HParamDef_HParamType& default_instance();

  enum KindCase {
    kInt64Value = 1,
    kFloatValue = 2,
    kBytesValue = 3,
    kBoolValue = 7,
    kInt64List = 4,
    kFloatList = 5,
    kBytesList = 6,
    kBoolList = 8,
    KIND_NOT_SET = 0,
  };

  static const HParamDef_HParamType* internal_default_instance();

  void UnsafeArenaSwap(HParamDef_HParamType* other);
  void Swap(HParamDef_HParamType* other);

  // implements Message ----------------------------------------------

  inline HParamDef_HParamType* New() const { return New(NULL); }

  HParamDef_HParamType* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HParamDef_HParamType& from);
  void MergeFrom(const HParamDef_HParamType& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HParamDef_HParamType* other);
  void UnsafeMergeFrom(const HParamDef_HParamType& from);
  protected:
  explicit HParamDef_HParamType(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 int64_value = 1;
  private:
  bool has_int64_value() const;
  public:
  void clear_int64_value();
  static const int kInt64ValueFieldNumber = 1;
  ::google::protobuf::int64 int64_value() const;
  void set_int64_value(::google::protobuf::int64 value);

  // optional float float_value = 2;
  private:
  bool has_float_value() const;
  public:
  void clear_float_value();
  static const int kFloatValueFieldNumber = 2;
  float float_value() const;
  void set_float_value(float value);

  // optional bytes bytes_value = 3;
  private:
  bool has_bytes_value() const;
  public:
  void clear_bytes_value();
  static const int kBytesValueFieldNumber = 3;
  const ::std::string& bytes_value() const;
  void set_bytes_value(const ::std::string& value);
  void set_bytes_value(const char* value);
  void set_bytes_value(const void* value, size_t size);
  ::std::string* mutable_bytes_value();
  ::std::string* release_bytes_value();
  void set_allocated_bytes_value(::std::string* bytes_value);
  ::std::string* unsafe_arena_release_bytes_value();
  void unsafe_arena_set_allocated_bytes_value(
      ::std::string* bytes_value);

  // optional bool bool_value = 7;
  private:
  bool has_bool_value() const;
  public:
  void clear_bool_value();
  static const int kBoolValueFieldNumber = 7;
  bool bool_value() const;
  void set_bool_value(bool value);

  // optional .tensorflow.HParamDef.Int64List int64_list = 4;
  bool has_int64_list() const;
  void clear_int64_list();
  static const int kInt64ListFieldNumber = 4;
  private:
  void _slow_mutable_int64_list();
  void _slow_set_allocated_int64_list(
      ::google::protobuf::Arena* message_arena, ::tensorflow::HParamDef_Int64List** int64_list);
  ::tensorflow::HParamDef_Int64List* _slow_release_int64_list();
  public:
  const ::tensorflow::HParamDef_Int64List& int64_list() const;
  ::tensorflow::HParamDef_Int64List* mutable_int64_list();
  ::tensorflow::HParamDef_Int64List* release_int64_list();
  void set_allocated_int64_list(::tensorflow::HParamDef_Int64List* int64_list);
  ::tensorflow::HParamDef_Int64List* unsafe_arena_release_int64_list();
  void unsafe_arena_set_allocated_int64_list(
      ::tensorflow::HParamDef_Int64List* int64_list);

  // optional .tensorflow.HParamDef.FloatList float_list = 5;
  bool has_float_list() const;
  void clear_float_list();
  static const int kFloatListFieldNumber = 5;
  private:
  void _slow_mutable_float_list();
  void _slow_set_allocated_float_list(
      ::google::protobuf::Arena* message_arena, ::tensorflow::HParamDef_FloatList** float_list);
  ::tensorflow::HParamDef_FloatList* _slow_release_float_list();
  public:
  const ::tensorflow::HParamDef_FloatList& float_list() const;
  ::tensorflow::HParamDef_FloatList* mutable_float_list();
  ::tensorflow::HParamDef_FloatList* release_float_list();
  void set_allocated_float_list(::tensorflow::HParamDef_FloatList* float_list);
  ::tensorflow::HParamDef_FloatList* unsafe_arena_release_float_list();
  void unsafe_arena_set_allocated_float_list(
      ::tensorflow::HParamDef_FloatList* float_list);

  // optional .tensorflow.HParamDef.BytesList bytes_list = 6;
  bool has_bytes_list() const;
  void clear_bytes_list();
  static const int kBytesListFieldNumber = 6;
  private:
  void _slow_mutable_bytes_list();
  void _slow_set_allocated_bytes_list(
      ::google::protobuf::Arena* message_arena, ::tensorflow::HParamDef_BytesList** bytes_list);
  ::tensorflow::HParamDef_BytesList* _slow_release_bytes_list();
  public:
  const ::tensorflow::HParamDef_BytesList& bytes_list() const;
  ::tensorflow::HParamDef_BytesList* mutable_bytes_list();
  ::tensorflow::HParamDef_BytesList* release_bytes_list();
  void set_allocated_bytes_list(::tensorflow::HParamDef_BytesList* bytes_list);
  ::tensorflow::HParamDef_BytesList* unsafe_arena_release_bytes_list();
  void unsafe_arena_set_allocated_bytes_list(
      ::tensorflow::HParamDef_BytesList* bytes_list);

  // optional .tensorflow.HParamDef.BoolList bool_list = 8;
  bool has_bool_list() const;
  void clear_bool_list();
  static const int kBoolListFieldNumber = 8;
  private:
  void _slow_mutable_bool_list();
  void _slow_set_allocated_bool_list(
      ::google::protobuf::Arena* message_arena, ::tensorflow::HParamDef_BoolList** bool_list);
  ::tensorflow::HParamDef_BoolList* _slow_release_bool_list();
  public:
  const ::tensorflow::HParamDef_BoolList& bool_list() const;
  ::tensorflow::HParamDef_BoolList* mutable_bool_list();
  ::tensorflow::HParamDef_BoolList* release_bool_list();
  void set_allocated_bool_list(::tensorflow::HParamDef_BoolList* bool_list);
  ::tensorflow::HParamDef_BoolList* unsafe_arena_release_bool_list();
  void unsafe_arena_set_allocated_bool_list(
      ::tensorflow::HParamDef_BoolList* bool_list);

  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.HParamDef.HParamType)
 private:
  inline void set_has_int64_value();
  inline void set_has_float_value();
  inline void set_has_bytes_value();
  inline void set_has_bool_value();
  inline void set_has_int64_list();
  inline void set_has_float_list();
  inline void set_has_bytes_list();
  inline void set_has_bool_list();

  inline bool has_kind() const;
  void clear_kind();
  inline void clear_has_kind();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union KindUnion {
    KindUnion() {}
    ::google::protobuf::int64 int64_value_;
    float float_value_;
    ::google::protobuf::internal::ArenaStringPtr bytes_value_;
    bool bool_value_;
    ::tensorflow::HParamDef_Int64List* int64_list_;
    ::tensorflow::HParamDef_FloatList* float_list_;
    ::tensorflow::HParamDef_BytesList* bytes_list_;
    ::tensorflow::HParamDef_BoolList* bool_list_;
  } kind_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_InitDefaults_tensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto_impl();
  friend void  protobuf_AddDesc_tensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto_impl();
  friend void protobuf_AssignDesc_tensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<HParamDef_HParamType> HParamDef_HParamType_default_instance_;

// -------------------------------------------------------------------

class HParamDef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.HParamDef) */ {
 public:
  HParamDef();
  virtual ~HParamDef();

  HParamDef(const HParamDef& from);

  inline HParamDef& operator=(const HParamDef& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const HParamDef& default_instance();

  static const HParamDef* internal_default_instance();

  void UnsafeArenaSwap(HParamDef* other);
  void Swap(HParamDef* other);

  // implements Message ----------------------------------------------

  inline HParamDef* New() const { return New(NULL); }

  HParamDef* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HParamDef& from);
  void MergeFrom(const HParamDef& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HParamDef* other);
  void UnsafeMergeFrom(const HParamDef& from);
  protected:
  explicit HParamDef(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef HParamDef_BytesList BytesList;
  typedef HParamDef_FloatList FloatList;
  typedef HParamDef_Int64List Int64List;
  typedef HParamDef_BoolList BoolList;
  typedef HParamDef_HParamType HParamType;

  // accessors -------------------------------------------------------

  // map<string, .tensorflow.HParamDef.HParamType> hparam = 1;
  int hparam_size() const;
  void clear_hparam();
  static const int kHparamFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::tensorflow::HParamDef_HParamType >&
      hparam() const;
  ::google::protobuf::Map< ::std::string, ::tensorflow::HParamDef_HParamType >*
      mutable_hparam();

  // @@protoc_insertion_point(class_scope:tensorflow.HParamDef)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::tensorflow::HParamDef_HParamType,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 >
      HParamDef_HparamEntry;
  ::google::protobuf::internal::MapField<
      ::std::string, ::tensorflow::HParamDef_HParamType,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > hparam_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto_impl();
  friend void  protobuf_AddDesc_tensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto_impl();
  friend void protobuf_AssignDesc_tensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<HParamDef> HParamDef_default_instance_;

// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// HParamDef_BytesList

// repeated bytes value = 1;
inline int HParamDef_BytesList::value_size() const {
  return value_.size();
}
inline void HParamDef_BytesList::clear_value() {
  value_.Clear();
}
inline const ::std::string& HParamDef_BytesList::value(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.HParamDef.BytesList.value)
  return value_.Get(index);
}
inline ::std::string* HParamDef_BytesList::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.HParamDef.BytesList.value)
  return value_.Mutable(index);
}
inline void HParamDef_BytesList::set_value(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorflow.HParamDef.BytesList.value)
  value_.Mutable(index)->assign(value);
}
inline void HParamDef_BytesList::set_value(int index, const char* value) {
  value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tensorflow.HParamDef.BytesList.value)
}
inline void HParamDef_BytesList::set_value(int index, const void* value, size_t size) {
  value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tensorflow.HParamDef.BytesList.value)
}
inline ::std::string* HParamDef_BytesList::add_value() {
  // @@protoc_insertion_point(field_add_mutable:tensorflow.HParamDef.BytesList.value)
  return value_.Add();
}
inline void HParamDef_BytesList::add_value(const ::std::string& value) {
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tensorflow.HParamDef.BytesList.value)
}
inline void HParamDef_BytesList::add_value(const char* value) {
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tensorflow.HParamDef.BytesList.value)
}
inline void HParamDef_BytesList::add_value(const void* value, size_t size) {
  value_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tensorflow.HParamDef.BytesList.value)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
HParamDef_BytesList::value() const {
  // @@protoc_insertion_point(field_list:tensorflow.HParamDef.BytesList.value)
  return value_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
HParamDef_BytesList::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.HParamDef.BytesList.value)
  return &value_;
}

inline const HParamDef_BytesList* HParamDef_BytesList::internal_default_instance() {
  return &HParamDef_BytesList_default_instance_.get();
}
// -------------------------------------------------------------------

// HParamDef_FloatList

// repeated float value = 1 [packed = true];
inline int HParamDef_FloatList::value_size() const {
  return value_.size();
}
inline void HParamDef_FloatList::clear_value() {
  value_.Clear();
}
inline float HParamDef_FloatList::value(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.HParamDef.FloatList.value)
  return value_.Get(index);
}
inline void HParamDef_FloatList::set_value(int index, float value) {
  value_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.HParamDef.FloatList.value)
}
inline void HParamDef_FloatList::add_value(float value) {
  value_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.HParamDef.FloatList.value)
}
inline const ::google::protobuf::RepeatedField< float >&
HParamDef_FloatList::value() const {
  // @@protoc_insertion_point(field_list:tensorflow.HParamDef.FloatList.value)
  return value_;
}
inline ::google::protobuf::RepeatedField< float >*
HParamDef_FloatList::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.HParamDef.FloatList.value)
  return &value_;
}

inline const HParamDef_FloatList* HParamDef_FloatList::internal_default_instance() {
  return &HParamDef_FloatList_default_instance_.get();
}
// -------------------------------------------------------------------

// HParamDef_Int64List

// repeated int64 value = 1 [packed = true];
inline int HParamDef_Int64List::value_size() const {
  return value_.size();
}
inline void HParamDef_Int64List::clear_value() {
  value_.Clear();
}
inline ::google::protobuf::int64 HParamDef_Int64List::value(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.HParamDef.Int64List.value)
  return value_.Get(index);
}
inline void HParamDef_Int64List::set_value(int index, ::google::protobuf::int64 value) {
  value_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.HParamDef.Int64List.value)
}
inline void HParamDef_Int64List::add_value(::google::protobuf::int64 value) {
  value_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.HParamDef.Int64List.value)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
HParamDef_Int64List::value() const {
  // @@protoc_insertion_point(field_list:tensorflow.HParamDef.Int64List.value)
  return value_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
HParamDef_Int64List::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.HParamDef.Int64List.value)
  return &value_;
}

inline const HParamDef_Int64List* HParamDef_Int64List::internal_default_instance() {
  return &HParamDef_Int64List_default_instance_.get();
}
// -------------------------------------------------------------------

// HParamDef_BoolList

// repeated bool value = 1 [packed = true];
inline int HParamDef_BoolList::value_size() const {
  return value_.size();
}
inline void HParamDef_BoolList::clear_value() {
  value_.Clear();
}
inline bool HParamDef_BoolList::value(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.HParamDef.BoolList.value)
  return value_.Get(index);
}
inline void HParamDef_BoolList::set_value(int index, bool value) {
  value_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.HParamDef.BoolList.value)
}
inline void HParamDef_BoolList::add_value(bool value) {
  value_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.HParamDef.BoolList.value)
}
inline const ::google::protobuf::RepeatedField< bool >&
HParamDef_BoolList::value() const {
  // @@protoc_insertion_point(field_list:tensorflow.HParamDef.BoolList.value)
  return value_;
}
inline ::google::protobuf::RepeatedField< bool >*
HParamDef_BoolList::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.HParamDef.BoolList.value)
  return &value_;
}

inline const HParamDef_BoolList* HParamDef_BoolList::internal_default_instance() {
  return &HParamDef_BoolList_default_instance_.get();
}
// -------------------------------------------------------------------

// HParamDef_HParamType

// optional int64 int64_value = 1;
inline bool HParamDef_HParamType::has_int64_value() const {
  return kind_case() == kInt64Value;
}
inline void HParamDef_HParamType::set_has_int64_value() {
  _oneof_case_[0] = kInt64Value;
}
inline void HParamDef_HParamType::clear_int64_value() {
  if (has_int64_value()) {
    kind_.int64_value_ = GOOGLE_LONGLONG(0);
    clear_has_kind();
  }
}
inline ::google::protobuf::int64 HParamDef_HParamType::int64_value() const {
  // @@protoc_insertion_point(field_get:tensorflow.HParamDef.HParamType.int64_value)
  if (has_int64_value()) {
    return kind_.int64_value_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void HParamDef_HParamType::set_int64_value(::google::protobuf::int64 value) {
  if (!has_int64_value()) {
    clear_kind();
    set_has_int64_value();
  }
  kind_.int64_value_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.HParamDef.HParamType.int64_value)
}

// optional float float_value = 2;
inline bool HParamDef_HParamType::has_float_value() const {
  return kind_case() == kFloatValue;
}
inline void HParamDef_HParamType::set_has_float_value() {
  _oneof_case_[0] = kFloatValue;
}
inline void HParamDef_HParamType::clear_float_value() {
  if (has_float_value()) {
    kind_.float_value_ = 0;
    clear_has_kind();
  }
}
inline float HParamDef_HParamType::float_value() const {
  // @@protoc_insertion_point(field_get:tensorflow.HParamDef.HParamType.float_value)
  if (has_float_value()) {
    return kind_.float_value_;
  }
  return 0;
}
inline void HParamDef_HParamType::set_float_value(float value) {
  if (!has_float_value()) {
    clear_kind();
    set_has_float_value();
  }
  kind_.float_value_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.HParamDef.HParamType.float_value)
}

// optional bytes bytes_value = 3;
inline bool HParamDef_HParamType::has_bytes_value() const {
  return kind_case() == kBytesValue;
}
inline void HParamDef_HParamType::set_has_bytes_value() {
  _oneof_case_[0] = kBytesValue;
}
inline void HParamDef_HParamType::clear_bytes_value() {
  if (has_bytes_value()) {
    kind_.bytes_value_.Destroy(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        GetArenaNoVirtual());
    clear_has_kind();
  }
}
inline const ::std::string& HParamDef_HParamType::bytes_value() const {
  // @@protoc_insertion_point(field_get:tensorflow.HParamDef.HParamType.bytes_value)
  if (has_bytes_value()) {
    return kind_.bytes_value_.Get(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void HParamDef_HParamType::set_bytes_value(const ::std::string& value) {
  if (!has_bytes_value()) {
    clear_kind();
    set_has_bytes_value();
    kind_.bytes_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  kind_.bytes_value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.HParamDef.HParamType.bytes_value)
}
inline void HParamDef_HParamType::set_bytes_value(const char* value) {
  if (!has_bytes_value()) {
    clear_kind();
    set_has_bytes_value();
    kind_.bytes_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  kind_.bytes_value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.HParamDef.HParamType.bytes_value)
}
inline void HParamDef_HParamType::set_bytes_value(const void* value,
                             size_t size) {
  if (!has_bytes_value()) {
    clear_kind();
    set_has_bytes_value();
    kind_.bytes_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  kind_.bytes_value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.HParamDef.HParamType.bytes_value)
}
inline ::std::string* HParamDef_HParamType::mutable_bytes_value() {
  if (!has_bytes_value()) {
    clear_kind();
    set_has_bytes_value();
    kind_.bytes_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return kind_.bytes_value_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_mutable:tensorflow.HParamDef.HParamType.bytes_value)
}
inline ::std::string* HParamDef_HParamType::release_bytes_value() {
  // @@protoc_insertion_point(field_release:tensorflow.HParamDef.HParamType.bytes_value)
  if (has_bytes_value()) {
    clear_has_kind();
    return kind_.bytes_value_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        GetArenaNoVirtual());
  } else {
    return NULL;
  }
}
inline ::std::string* HParamDef_HParamType::unsafe_arena_release_bytes_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.HParamDef.HParamType.bytes_value)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (has_bytes_value()) {
    clear_has_kind();
    return kind_.bytes_value_.UnsafeArenaRelease(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  } else {
    return NULL;
  }
}
inline void HParamDef_HParamType::set_allocated_bytes_value(::std::string* bytes_value) {
  if (!has_bytes_value()) {
    kind_.bytes_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_kind();
  if (bytes_value != NULL) {
    set_has_bytes_value();
    kind_.bytes_value_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bytes_value,
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.HParamDef.HParamType.bytes_value)
}
inline void HParamDef_HParamType::unsafe_arena_set_allocated_bytes_value(::std::string* bytes_value) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (!has_bytes_value()) {
    kind_.bytes_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_kind();
  if (bytes_value) {
    set_has_bytes_value();
    kind_.bytes_value_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bytes_value, GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.HParamDef.HParamType.bytes_value)
}

// optional bool bool_value = 7;
inline bool HParamDef_HParamType::has_bool_value() const {
  return kind_case() == kBoolValue;
}
inline void HParamDef_HParamType::set_has_bool_value() {
  _oneof_case_[0] = kBoolValue;
}
inline void HParamDef_HParamType::clear_bool_value() {
  if (has_bool_value()) {
    kind_.bool_value_ = false;
    clear_has_kind();
  }
}
inline bool HParamDef_HParamType::bool_value() const {
  // @@protoc_insertion_point(field_get:tensorflow.HParamDef.HParamType.bool_value)
  if (has_bool_value()) {
    return kind_.bool_value_;
  }
  return false;
}
inline void HParamDef_HParamType::set_bool_value(bool value) {
  if (!has_bool_value()) {
    clear_kind();
    set_has_bool_value();
  }
  kind_.bool_value_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.HParamDef.HParamType.bool_value)
}

// optional .tensorflow.HParamDef.Int64List int64_list = 4;
inline bool HParamDef_HParamType::has_int64_list() const {
  return kind_case() == kInt64List;
}
inline void HParamDef_HParamType::set_has_int64_list() {
  _oneof_case_[0] = kInt64List;
}
inline void HParamDef_HParamType::clear_int64_list() {
  if (has_int64_list()) {
    if (GetArenaNoVirtual() == NULL) {
      delete kind_.int64_list_;
    }
    clear_has_kind();
  }
}
inline  const ::tensorflow::HParamDef_Int64List& HParamDef_HParamType::int64_list() const {
  // @@protoc_insertion_point(field_get:tensorflow.HParamDef.HParamType.int64_list)
  return has_int64_list()
      ? *kind_.int64_list_
      : ::tensorflow::HParamDef_Int64List::default_instance();
}
inline ::tensorflow::HParamDef_Int64List* HParamDef_HParamType::mutable_int64_list() {
  if (!has_int64_list()) {
    clear_kind();
    set_has_int64_list();
    kind_.int64_list_ = 
      ::google::protobuf::Arena::CreateMessage< ::tensorflow::HParamDef_Int64List >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.HParamDef.HParamType.int64_list)
  return kind_.int64_list_;
}
inline ::tensorflow::HParamDef_Int64List* HParamDef_HParamType::release_int64_list() {
  // @@protoc_insertion_point(field_release:tensorflow.HParamDef.HParamType.int64_list)
  if (has_int64_list()) {
    clear_has_kind();
    if (GetArenaNoVirtual() != NULL) {
      ::tensorflow::HParamDef_Int64List* temp = new ::tensorflow::HParamDef_Int64List(*kind_.int64_list_);
      kind_.int64_list_ = NULL;
      return temp;
    } else {
      ::tensorflow::HParamDef_Int64List* temp = kind_.int64_list_;
      kind_.int64_list_ = NULL;
      return temp;
    }
  } else {
    return NULL;
  }
}
inline void HParamDef_HParamType::set_allocated_int64_list(::tensorflow::HParamDef_Int64List* int64_list) {
  clear_kind();
  if (int64_list) {
    if (GetArenaNoVirtual() != NULL &&
        ::google::protobuf::Arena::GetArena(int64_list) == NULL) {
      GetArenaNoVirtual()->Own(int64_list);
    } else if (GetArenaNoVirtual() !=
               ::google::protobuf::Arena::GetArena(int64_list)) {
      ::tensorflow::HParamDef_Int64List* new_int64_list = 
          ::google::protobuf::Arena::CreateMessage< ::tensorflow::HParamDef_Int64List >(
          GetArenaNoVirtual());
      new_int64_list->CopyFrom(*int64_list);
      int64_list = new_int64_list;
    }
    set_has_int64_list();
    kind_.int64_list_ = int64_list;
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.HParamDef.HParamType.int64_list)
}
inline  ::tensorflow::HParamDef_Int64List* HParamDef_HParamType::unsafe_arena_release_int64_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.HParamDef.HParamType.int64_list)
  if (has_int64_list()) {
    clear_has_kind();
    ::tensorflow::HParamDef_Int64List* temp = kind_.int64_list_;
    kind_.int64_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline  void HParamDef_HParamType::unsafe_arena_set_allocated_int64_list(::tensorflow::HParamDef_Int64List* int64_list) {
  clear_kind();
  if (int64_list) {
    set_has_int64_list();
    kind_.int64_list_ = int64_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.HParamDef.HParamType.int64_list)
}

// optional .tensorflow.HParamDef.FloatList float_list = 5;
inline bool HParamDef_HParamType::has_float_list() const {
  return kind_case() == kFloatList;
}
inline void HParamDef_HParamType::set_has_float_list() {
  _oneof_case_[0] = kFloatList;
}
inline void HParamDef_HParamType::clear_float_list() {
  if (has_float_list()) {
    if (GetArenaNoVirtual() == NULL) {
      delete kind_.float_list_;
    }
    clear_has_kind();
  }
}
inline  const ::tensorflow::HParamDef_FloatList& HParamDef_HParamType::float_list() const {
  // @@protoc_insertion_point(field_get:tensorflow.HParamDef.HParamType.float_list)
  return has_float_list()
      ? *kind_.float_list_
      : ::tensorflow::HParamDef_FloatList::default_instance();
}
inline ::tensorflow::HParamDef_FloatList* HParamDef_HParamType::mutable_float_list() {
  if (!has_float_list()) {
    clear_kind();
    set_has_float_list();
    kind_.float_list_ = 
      ::google::protobuf::Arena::CreateMessage< ::tensorflow::HParamDef_FloatList >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.HParamDef.HParamType.float_list)
  return kind_.float_list_;
}
inline ::tensorflow::HParamDef_FloatList* HParamDef_HParamType::release_float_list() {
  // @@protoc_insertion_point(field_release:tensorflow.HParamDef.HParamType.float_list)
  if (has_float_list()) {
    clear_has_kind();
    if (GetArenaNoVirtual() != NULL) {
      ::tensorflow::HParamDef_FloatList* temp = new ::tensorflow::HParamDef_FloatList(*kind_.float_list_);
      kind_.float_list_ = NULL;
      return temp;
    } else {
      ::tensorflow::HParamDef_FloatList* temp = kind_.float_list_;
      kind_.float_list_ = NULL;
      return temp;
    }
  } else {
    return NULL;
  }
}
inline void HParamDef_HParamType::set_allocated_float_list(::tensorflow::HParamDef_FloatList* float_list) {
  clear_kind();
  if (float_list) {
    if (GetArenaNoVirtual() != NULL &&
        ::google::protobuf::Arena::GetArena(float_list) == NULL) {
      GetArenaNoVirtual()->Own(float_list);
    } else if (GetArenaNoVirtual() !=
               ::google::protobuf::Arena::GetArena(float_list)) {
      ::tensorflow::HParamDef_FloatList* new_float_list = 
          ::google::protobuf::Arena::CreateMessage< ::tensorflow::HParamDef_FloatList >(
          GetArenaNoVirtual());
      new_float_list->CopyFrom(*float_list);
      float_list = new_float_list;
    }
    set_has_float_list();
    kind_.float_list_ = float_list;
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.HParamDef.HParamType.float_list)
}
inline  ::tensorflow::HParamDef_FloatList* HParamDef_HParamType::unsafe_arena_release_float_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.HParamDef.HParamType.float_list)
  if (has_float_list()) {
    clear_has_kind();
    ::tensorflow::HParamDef_FloatList* temp = kind_.float_list_;
    kind_.float_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline  void HParamDef_HParamType::unsafe_arena_set_allocated_float_list(::tensorflow::HParamDef_FloatList* float_list) {
  clear_kind();
  if (float_list) {
    set_has_float_list();
    kind_.float_list_ = float_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.HParamDef.HParamType.float_list)
}

// optional .tensorflow.HParamDef.BytesList bytes_list = 6;
inline bool HParamDef_HParamType::has_bytes_list() const {
  return kind_case() == kBytesList;
}
inline void HParamDef_HParamType::set_has_bytes_list() {
  _oneof_case_[0] = kBytesList;
}
inline void HParamDef_HParamType::clear_bytes_list() {
  if (has_bytes_list()) {
    if (GetArenaNoVirtual() == NULL) {
      delete kind_.bytes_list_;
    }
    clear_has_kind();
  }
}
inline  const ::tensorflow::HParamDef_BytesList& HParamDef_HParamType::bytes_list() const {
  // @@protoc_insertion_point(field_get:tensorflow.HParamDef.HParamType.bytes_list)
  return has_bytes_list()
      ? *kind_.bytes_list_
      : ::tensorflow::HParamDef_BytesList::default_instance();
}
inline ::tensorflow::HParamDef_BytesList* HParamDef_HParamType::mutable_bytes_list() {
  if (!has_bytes_list()) {
    clear_kind();
    set_has_bytes_list();
    kind_.bytes_list_ = 
      ::google::protobuf::Arena::CreateMessage< ::tensorflow::HParamDef_BytesList >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.HParamDef.HParamType.bytes_list)
  return kind_.bytes_list_;
}
inline ::tensorflow::HParamDef_BytesList* HParamDef_HParamType::release_bytes_list() {
  // @@protoc_insertion_point(field_release:tensorflow.HParamDef.HParamType.bytes_list)
  if (has_bytes_list()) {
    clear_has_kind();
    if (GetArenaNoVirtual() != NULL) {
      ::tensorflow::HParamDef_BytesList* temp = new ::tensorflow::HParamDef_BytesList(*kind_.bytes_list_);
      kind_.bytes_list_ = NULL;
      return temp;
    } else {
      ::tensorflow::HParamDef_BytesList* temp = kind_.bytes_list_;
      kind_.bytes_list_ = NULL;
      return temp;
    }
  } else {
    return NULL;
  }
}
inline void HParamDef_HParamType::set_allocated_bytes_list(::tensorflow::HParamDef_BytesList* bytes_list) {
  clear_kind();
  if (bytes_list) {
    if (GetArenaNoVirtual() != NULL &&
        ::google::protobuf::Arena::GetArena(bytes_list) == NULL) {
      GetArenaNoVirtual()->Own(bytes_list);
    } else if (GetArenaNoVirtual() !=
               ::google::protobuf::Arena::GetArena(bytes_list)) {
      ::tensorflow::HParamDef_BytesList* new_bytes_list = 
          ::google::protobuf::Arena::CreateMessage< ::tensorflow::HParamDef_BytesList >(
          GetArenaNoVirtual());
      new_bytes_list->CopyFrom(*bytes_list);
      bytes_list = new_bytes_list;
    }
    set_has_bytes_list();
    kind_.bytes_list_ = bytes_list;
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.HParamDef.HParamType.bytes_list)
}
inline  ::tensorflow::HParamDef_BytesList* HParamDef_HParamType::unsafe_arena_release_bytes_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.HParamDef.HParamType.bytes_list)
  if (has_bytes_list()) {
    clear_has_kind();
    ::tensorflow::HParamDef_BytesList* temp = kind_.bytes_list_;
    kind_.bytes_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline  void HParamDef_HParamType::unsafe_arena_set_allocated_bytes_list(::tensorflow::HParamDef_BytesList* bytes_list) {
  clear_kind();
  if (bytes_list) {
    set_has_bytes_list();
    kind_.bytes_list_ = bytes_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.HParamDef.HParamType.bytes_list)
}

// optional .tensorflow.HParamDef.BoolList bool_list = 8;
inline bool HParamDef_HParamType::has_bool_list() const {
  return kind_case() == kBoolList;
}
inline void HParamDef_HParamType::set_has_bool_list() {
  _oneof_case_[0] = kBoolList;
}
inline void HParamDef_HParamType::clear_bool_list() {
  if (has_bool_list()) {
    if (GetArenaNoVirtual() == NULL) {
      delete kind_.bool_list_;
    }
    clear_has_kind();
  }
}
inline  const ::tensorflow::HParamDef_BoolList& HParamDef_HParamType::bool_list() const {
  // @@protoc_insertion_point(field_get:tensorflow.HParamDef.HParamType.bool_list)
  return has_bool_list()
      ? *kind_.bool_list_
      : ::tensorflow::HParamDef_BoolList::default_instance();
}
inline ::tensorflow::HParamDef_BoolList* HParamDef_HParamType::mutable_bool_list() {
  if (!has_bool_list()) {
    clear_kind();
    set_has_bool_list();
    kind_.bool_list_ = 
      ::google::protobuf::Arena::CreateMessage< ::tensorflow::HParamDef_BoolList >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.HParamDef.HParamType.bool_list)
  return kind_.bool_list_;
}
inline ::tensorflow::HParamDef_BoolList* HParamDef_HParamType::release_bool_list() {
  // @@protoc_insertion_point(field_release:tensorflow.HParamDef.HParamType.bool_list)
  if (has_bool_list()) {
    clear_has_kind();
    if (GetArenaNoVirtual() != NULL) {
      ::tensorflow::HParamDef_BoolList* temp = new ::tensorflow::HParamDef_BoolList(*kind_.bool_list_);
      kind_.bool_list_ = NULL;
      return temp;
    } else {
      ::tensorflow::HParamDef_BoolList* temp = kind_.bool_list_;
      kind_.bool_list_ = NULL;
      return temp;
    }
  } else {
    return NULL;
  }
}
inline void HParamDef_HParamType::set_allocated_bool_list(::tensorflow::HParamDef_BoolList* bool_list) {
  clear_kind();
  if (bool_list) {
    if (GetArenaNoVirtual() != NULL &&
        ::google::protobuf::Arena::GetArena(bool_list) == NULL) {
      GetArenaNoVirtual()->Own(bool_list);
    } else if (GetArenaNoVirtual() !=
               ::google::protobuf::Arena::GetArena(bool_list)) {
      ::tensorflow::HParamDef_BoolList* new_bool_list = 
          ::google::protobuf::Arena::CreateMessage< ::tensorflow::HParamDef_BoolList >(
          GetArenaNoVirtual());
      new_bool_list->CopyFrom(*bool_list);
      bool_list = new_bool_list;
    }
    set_has_bool_list();
    kind_.bool_list_ = bool_list;
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.HParamDef.HParamType.bool_list)
}
inline  ::tensorflow::HParamDef_BoolList* HParamDef_HParamType::unsafe_arena_release_bool_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.HParamDef.HParamType.bool_list)
  if (has_bool_list()) {
    clear_has_kind();
    ::tensorflow::HParamDef_BoolList* temp = kind_.bool_list_;
    kind_.bool_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline  void HParamDef_HParamType::unsafe_arena_set_allocated_bool_list(::tensorflow::HParamDef_BoolList* bool_list) {
  clear_kind();
  if (bool_list) {
    set_has_bool_list();
    kind_.bool_list_ = bool_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.HParamDef.HParamType.bool_list)
}

inline bool HParamDef_HParamType::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void HParamDef_HParamType::clear_has_kind() {
  _oneof_case_[0] = KIND_NOT_SET;
}
inline HParamDef_HParamType::KindCase HParamDef_HParamType::kind_case() const {
  return HParamDef_HParamType::KindCase(_oneof_case_[0]);
}
inline const HParamDef_HParamType* HParamDef_HParamType::internal_default_instance() {
  return &HParamDef_HParamType_default_instance_.get();
}
// -------------------------------------------------------------------

// HParamDef

// map<string, .tensorflow.HParamDef.HParamType> hparam = 1;
inline int HParamDef::hparam_size() const {
  return hparam_.size();
}
inline void HParamDef::clear_hparam() {
  hparam_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::tensorflow::HParamDef_HParamType >&
HParamDef::hparam() const {
  // @@protoc_insertion_point(field_map:tensorflow.HParamDef.hparam)
  return hparam_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::tensorflow::HParamDef_HParamType >*
HParamDef::mutable_hparam() {
  // @@protoc_insertion_point(field_mutable_map:tensorflow.HParamDef.hparam)
  return hparam_.MutableMap();
}

inline const HParamDef* HParamDef::internal_default_instance() {
  return &HParamDef_default_instance_.get();
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tensorflow

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_tensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto__INCLUDED
